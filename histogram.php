<?php/** * Returns histogram filepath and array of values. */function histogram_make_histogram($image, $color = "#000000", $forcebw = FALSE, $histType = 1, $histW = 256) {  set_time_limit(50000);  if (!isset($image)) {    drupal_set_message(t('An error occurred and processing did not complete.'), 'error');  }//HISTOGRAM VARIABLES  $source_file = file_create_url($image);  $maxheight = 100;  $iscolor = FALSE;  $path = str_replace('public:/', variable_get('file_public_path', 'sites/default/files'), $image);  $file_basename = drupal_basename($image);  $directory = str_replace($file_basename,"",$path);  $directory .= 'histograms';  if (!is_dir($directory)) {    drupal_mkdir($directory);  };  $img = ImageCreateFromJpeg($source_file);  $imgw = imagesx($img);  $imgh = imagesy($img);  $step = 4;  $histogram = array();  $histogramR = array();  $histogramG = array();  $histogramB = array();  $histogramComputed = array();  $histogramComplete = array();  $histogramRcompiled = array();  $histogramGcompiled = array();  $histogramBcompiled = array();// ZERO HISTOGRAM VALUES  for ($i = 0; $i < 256; $i++) {    $histogram[$i] = 0;    $histogramR[$i] = 0;    $histogramG[$i] = 0;    $histogramB[$i] = 0;  }// CALCULATE PIXELS  for ($i = 0; $i < $imgw; $i += $step) {    for ($j = 0; $j < $imgh; $j += $step) {      $rgb = ImageColorAt($img, $i, $j);      $r = ($rgb >> 16) & 0xFF;      $g = ($rgb >> 8) & 0xFF;      $b = $rgb & 0xFF;      $V = round(($r + $g + $b) / 3);      $histogram[$V] += 1;      $V = round($r * 1);      $histogramR[$V] += 1;      $V = round($g * 1);      $histogramG[$V] += 1;      $V = round($b * 1);      $histogramB[$V] += 1;    }  }  imagedestroy($img);// AUTOMATIC GRAYSCALE DETECTION  if ($forcebw != TRUE) {    for ($a = 0; $a < count($histogramR); $a++) {      if ($histogramR[$a] != $histogramG[$a] || $histogramG[$a] != $histogramB[$a]) {        $iscolor = TRUE;        break;      }    }  }//CREATE HISTOGRAM IMAGE  if (($histType == '1') or ($iscolor == FALSE)) {    $imR = imagecreatetruecolor(256, 100)    or die ("Cannot Initialize new GD image stream");  }  else {    $imR = imagecreatetruecolor(256, 300)    or die ("Cannot Initialize new GD image stream");  }// CONVERT BACKGROUND COLOR TO RGB  if (empty($color)) {    imagealphablending($imR, false);    imagesavealpha($imR, true);    $back = imagecolorallocatealpha($imR, 0, 0, 0, 127);  } else {    $rgbcolor = histogram_html2rgb($color);    // MAKE BACKGROUND    $back = imagecolorallocate($imR, $rgbcolor[0], $rgbcolor[1], $rgbcolor[2]);  }//RGB  if ($iscolor) {    // compute bounds of vertical axis    // sort the histograms to find tallest bins    $sHistoR = $histogramR;    $sHistoG = $histogramG;    $sHistoB = $histogramB;    sort($sHistoR);    sort($sHistoG);    sort($sHistoB);    // allow clipping of at most the 5 tallest histogram bins, but clipping    // also needs to be useful. i.e. if clipping does not change the vertical    // range much, then don't do it. The following heuristic code enforces this.    $lerpR = min(max(($sHistoR[255] / $sHistoR[250] - 1.15) / 2.0, 0.0), 1.0);    $lerpG = min(max(($sHistoG[255] / $sHistoG[250] - 1.15) / 2.0, 0.0), 1.0);    $lerpB = min(max(($sHistoB[255] / $sHistoB[250] - 1.15) / 2.0, 0.0), 1.0);    $histogramClipR = (1.0 - $lerpR) * $sHistoR[255] + $lerpR * $sHistoR[250];    $histogramClipG = (1.0 - $lerpG) * $sHistoG[255] + $lerpG * $sHistoG[250];    $histogramClipB = (1.0 - $lerpB) * $sHistoB[255] + $lerpB * $sHistoB[250];    $histogramClip = max($histogramClipR, $histogramClipG, $histogramClipB);    if ($histType == '1') {      // COMBINED COLOR HISTOGRAM      imagefilledrectangle($imR, 0, 0, 256, 100, $back);      imagefill($imR, 0, 0, $back);      // CREATE GRAPH      for ($a = 0; $a < 256; $a++) {        $heightsRGB = array(          min($histogramR[$a] / $histogramClip, 1.0) * $maxheight,          min($histogramG[$a] / $histogramClip, 1.0) * $maxheight,          min($histogramB[$a] / $histogramClip, 1.0) * $maxheight        );        $histogramComputed[$a] = $heightsRGB;        $lineOrder = array(0, 1, 2);        array_multisort($heightsRGB, $lineOrder);        // Draw 3 vertical lines.        // First a white line, for the extent that all the histograms overlap,        // Then as we cross each histogram, remove that appropriate color        // component.        $lineRGB = array(255, 255, 255);        $lineColor = ImageColorAllocateAlpha($imR, $lineRGB[0], $lineRGB[1], $lineRGB[2], 0);        $start = $maxheight - $heightsRGB[0];        $end = $maxheight;        imageline($imR, ($a + 1), $start, ($a + 1), $end, $lineColor);        $lineRGB[$lineOrder[0]] = 0;        $lineColor = ImageColorAllocateAlpha($imR, $lineRGB[0], $lineRGB[1], $lineRGB[2], 0);        $start = $maxheight - $heightsRGB[1];        $end = $maxheight - $heightsRGB[0];        imageline($imR, ($a + 1), $start, ($a + 1), $end, $lineColor);        $lineRGB[$lineOrder[1]] = 0;        $lineColor = ImageColorAllocateAlpha($imR, $lineRGB[0], $lineRGB[1], $lineRGB[2], 0);        $start = $maxheight - $heightsRGB[2];        $end = $maxheight - $heightsRGB[1];        imageline($imR, ($a + 1), $start, ($a + 1), $end, $lineColor);      }    }    else { // SEPARATE R G B HISTOGRAMS      imagefilledrectangle($imR, 0, 0, 256, 300, $back);      imagefill($imR, 0, 0, $back);      // CREATE GRAPH      for ($a = 0; $a < 256; $a++) {        $lineColor = ImageColorAllocateAlpha($imR, 255, 0, 0, 0);        $start = $maxheight - min($histogramR[$a] / $histogramClipR, 1.0) * $maxheight;        $end = $maxheight;        imageline($imR, ($a + 1), $start, ($a + 1), $end, $lineColor);        $histogramRcompiled[] = floor(min($histogramR[$a] / $histogramClipR, 1.0) * $maxheight);        $lineColor = ImageColorAllocateAlpha($imR, 0, 255, 0, 0);        $start = $maxheight - min($histogramG[$a] / $histogramClipG, 1.0) * $maxheight;        $end = $maxheight;        imageline($imR, ($a + 1), $start + 100, ($a + 1), $end + 100, $lineColor);        $histogramGcompiled[] = floor($start);        $lineColor = ImageColorAllocateAlpha($imR, 0, 0, 255, 0);        $start = $maxheight - min($histogramB[$a] / $histogramClipB, 1.0) * $maxheight;        $end = $maxheight;        imageline($imR, ($a + 1), $start + 200, ($a + 1), $end + 200, $lineColor);        $histogramBcompiled[] = floor($start);      }    }  }  else { // GRAYSCALE    // COMPUTE MAX VALUES    //$max = max($histogram);    // sort the histogram to find tallest bins    $sortedHisto = $histogram;    sort($sortedHisto);    // we allow clipping of at most the 5 tallest histogram bins, but clipping    // also needs to be useful. i.e. if clipping does not change the vertical    // range much, then don't do it. The following heuristic code enforces this.    $lerpFactor = min(max(($sortedHisto[255] / $sortedHisto[250] - 1.15) / 2.0, 0.0), 1.0);    $histogramClip = (1.0 - $lerpFactor) * $sortedHisto[255] + $lerpFactor * $sortedHisto[250];    // CREATE HISTOGRAM BACKGROUND    imagefilledrectangle($imR, 0, 0, 256, 100, $back);    // MAKE HISTOGRAM COLOR NOT MATCH BACKGROUND LIGHTNESS    if (empty($color) || (($rgbcolor[0] + $rgbcolor[0] + $rgbcolor[0]) / 3) < 127) {      $graphcolor = 255;    }    else {      $graphcolor = 0;    }    $text_color = ImageColorAllocateAlpha($imR, $graphcolor, $graphcolor, $graphcolor, 0);    // CREATE HISTOGRAM    for ($a = 0; $a < 256; $a++) {      $h = min($histogram[$a] / $histogramClip, 1.0) * $maxheight;      $histogramComputed[$a] = $h;      $start = ($maxheight - $h);      imageline($imR, ($a + 1), $start, ($a + 1), $maxheight, $text_color);    }    // ENG GRAYSCALE HISTOGRAM  }// SAVE HISTOGRAM AND DESTROY RESOURCE  if (is_writable($directory)) {    touch($directory . "/hist_" . $file_basename);    if ($histW != 256) {      $newW = $histW;      $scale = $newW / 256;      $width = imagesx($imR);      $height = imagesy($imR);      $new_width = floor($scale * $width);      $new_height = floor($scale * $height);      $tmp_img = imagecreatetruecolor($new_width, $new_height);      // gd 2.0.1 or later: imagecopyresampled      // gd less than 2.0: imagecopyresized      if (function_exists(imagecopyresampled)) {        imagecopyresampled($tmp_img, $imR, 0, 0, 0, 0, $new_width, $new_height, $width, $height);      }      else {        imagecopyresized($tmp_img, $imR, 0, 0, 0, 0, $new_width, $new_height, $width, $height);      }      imagedestroy($imR);      $imR = $tmp_img;    }    imagepng($imR, $directory . "/hist_" . $file_basename . ".png");    $histogramComplete[0] = $directory . "/hist_" . $file_basename . ".png";    $histogramComplete[1] = $histogramComputed;    //chmod($histogramComplete[0], 0644);    imagedestroy($imR);    //$perms = fileperms($directory);    drupal_set_message(t('Histogram Created.'));  }  else {    drupal_set_message(t('The folder is not writable.'), 'error');  }  return $histogramComplete;}/** * Returns RGB values from hexdec color */function histogram_html2rgb($color) {  if ($color[0] == '#') {    $color = substr($color, 1);  }  if (strlen($color) == 6) {    list($r, $g, $b) = array(      $color[0] . $color[1],      $color[2] . $color[3],      $color[4] . $color[5]    );  }  elseif (strlen($color) == 3) {    list($r, $g, $b) = array($color[0], $color[1], $color[2]);  }  else {    return FALSE;  }  $r = hexdec($r);  $g = hexdec($g);  $b = hexdec($b);  return array($r, $g, $b);}